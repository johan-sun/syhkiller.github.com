---
layout : article
title : AVL-Tree
category : 数据结构
tag : 平衡树
---

AVL平衡树是一颗二叉搜索树，并且通过一系列旋转操作保持树的平衡，分LL，LR，RL，RR，其中LL，RR与LR，RL对称。

##平衡树的插入
由于二叉搜索树的中序遍历就是一个有序数组，我们这里用数组加括号表示一科树，大写字母表示一整棵树，小写字母表示树根，如$AxB$表示一棵树树根为x，
左子树为A，右子树为B。

###AVL的旋转操作
AVL的旋转操作实际上保证了二叉搜索树旋转后仍然是一颗二叉所搜树，有了以上的表示方法，我们很容易证明旋转操作的正确性，对于一棵树$(AxB)yC$表示树根为y，左子树为$(AxB)$，
右子树为C，左子树的树根为x，左子树的左子树为A，左子树的右子树为B。

对节点y做右旋操作，我们可以得到$(AxB)yC \rightarrow Ax(ByC)$，那么旋转操作可以认为是结合律，基对于某个节点左旋转，及相应的将相邻的括号移动到节点所在的位置。

###外插
设$b(x)$表示节点的平衡因子，-1标识左子树比右子树高1层，0标识一样高，1表示右子树比左子树高一层, 用b'(x)表示对x进行旋转操作后的平衡因子。

设$h(T)$表示树T的高度，已知AVL树$AxB$, 发现插入z到A后，树失衡，x是回溯上来的第一个失衡跟节点。

设$h(B) = l$，我们有$h(A) = l + 1$，$b(x) = -1$，我们将A展开，有$A = CyD$，及$AxB = (CyD)xB$，有$h(CyD) = h(A) = l + 1, \max(h(C), h(D)) = l$

并且我们可以证明$h(C) = h(D) = l$，假设$h(C) > h(D)$，如果z插入到C，那么第一个失衡节点将是y，如果插入到D，那么树不会增高，x将不会失衡，所以我们有

$$
\begin{split}
h(B) &= l\\
h(C) &= l\\
h(D) &= l\\
h(CyD) &= \max(h(C), h(D)) + 1 = l + 1\\
h((CyD)xB) &= \max(h(CyD), h(B)) + 1 = l + 2
\end{split}
$$

如果z插入到C，我们得到$(C'yD)xB$，其中$h(C') = l+1,b(y) = -1, b(x) = -2$，这就是一个外插，我们对x做右旋操作，得到$C'y(DxB)$，此时$b'(y) = 0, b'(x) = 0$，树没有增高。

###内插

对于$(CyD)xB$如果z插入到D中失衡，我们需要将D在递归展开，原树就是$(Cy(EmF))xB$，我们可以知道$h(EmF) = \max(h(E), h(F)) + 1 = l$，同理我们还是可以证明$h(E) = h(F) = l - 1$，
插入z后树变为$(Cy(E'mF))xB$或者$(Cy(EmF'))xB$，我们有

$$
\begin{split}
h(B) &= l\\
h(C) &= l\\
h(E) &= l - 1\\
h(F) &= l - 1\\
h(E') &= l\\
h(F') &= l\\
h(EmF) &= l\\
h(E'mF) &= l + 1\\
h(EmF') &= l + 1\\
\end{split}
$$

前者$b(m) = -1$，后者$b(m) = 1$, 两者的$b(y) = 1, b(x) = -2$, 通过对y左旋得到$((CyE)mF')xB$或者$((CyE')mF)xB$，然后对x右旋得到
$(CyE')m(FxB)$或者$(CyE)m(F'xB)$，其中前者$b'(y) = 0, b'(x) = 1$，后者$b'(y) = -1, b'(x) = 0$， 两者$b'(m) = 0$，树没有增高。

当然考虑D与C是空树，那么就是$(y(z))x \rightarrow ((y)z)x \rightarrow (y)z(x)$, $b'(z) = b'(x) = b'(y) = 0$

###代码
{% highlight c linenos %}
struct Node
{
    int data;
    int balance;
    Node* left;
    Node* right;
    Node( int key  ):data(key),balance(0),left(nullptr),right(nullptr){}
};

void right_rotate(Node** proot)
{
    Node* left = (*proot)->left;
    (*proot)->left = left->right;
    left->right = *proot;
    *proot = left;

}
void left_rotate(Node** proot)
{
    Node* right = (*proot)->right;
    (*proot)->right = right->left;
    right->left = *proot;
    *proot = right;

}
//有了以上的分析，我们只要在insert返回proot是否增高就能很方便的写出插入函数
int insert(Node** proot, int key)
{
    if ( (*proot) == NULL  )
    {
        (*proot) = new Node(key);
        return 1;

    }

    if ( key < (*proot)->data  )
    {
        int acc = insert(&(*proot)->left, key);
        int rt = (*proot)->balance == 0 && acc != 0;//原来平衡，变不平衡，肯定有子树增高
        (*proot)->balance -= acc;
        if ( (*proot)->balance == -2 )
        {
            if ( (*proot)->left->balance ==  -1 )
            {//外插
                right_rotate(proot);
                (*proot)->balance = 0;
                (*proot)->right->balance = 0;
            }else 
            {//内插
                assert( (*proot)->left->balance == 1  );
                if ( (*proot)->left->right->data == key  )
                {
                    left_rotate(&(*proot)->left);
                    right_rotate(proot);
                    (*proot)->balance = 0;
                    (*proot)->left->balance = (*proot)->right->balance = 0;

                }else{
                    int b = (*proot)->left->right->balance; assert( b == -1 || b == 1  );
                    left_rotate(&(*proot)->left);
                    right_rotate(proot);
                    (*proot)->left->balance = b == -1? 0:-1;
                    (*proot)->right->balance = b == -1?  1: 0;
                    (*proot)->balance = 0;
                }
            }
            return 0;//旋转后一定不会增高
        }
        return rt;//返回是否增高
    }else if ( key >  (*proot)->data )
    {
        int acc = insert(&(*proot)->right, key);
        int rt = (*proot)->balance == 0 && acc != 0;
        (*proot)->balance += acc;
        if ( (*proot)->balance == 2 )
        {
            if ( (*proot)->right->balance ==  1 )
            {//外插
                left_rotate(proot);
                (*proot)->balance = 0;
                (*proot)->left->balance = 0;
            }else 
            {//内插
                assert( (*proot)->right->balance == -1  );
                if( (*proot)->right->left->data == key  )
                {
                    right_rotate(&(*proot)->right);
                    left_rotate(proot);
                    (*proot)->balance = (*proot)->left->balance = (*proot)->right->balance = 0;
                }else
                {
                    int b = (*proot)->right->left->balance;
                    assert( b == -1 || b == 1  );
                    right_rotate(&(*proot)->right);
                    left_rotate(proot);
                    (*proot)->left->balance = b == -1 ? 0:-1;
                    (*proot)->right->balance = b == -1 ? 1:0;
                    (*proot)->balance = 0;
                }
            }
            return 0;//旋转后子树一定不会增高
        }
        return rt;//返回这棵树是否增高
    }
    //已存在元素不做处理
    return 0;
}
{% endhighlight %}
